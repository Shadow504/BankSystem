package bank;

import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.sql.rowset.CachedRowSet;
import javax.sql.rowset.RowSetProvider;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;


import com.mysql.cj.jdbc.MysqlConnectionPoolDataSource;

import bank.account.BankAccount;
import bank.client.ClientClass;

//* Each client should hold a single loan handler */
public class LoanHandler {

    static final String PENDING = "Pending";
    static final String PAID = "Paid";

    static final int MAX_LOAN = 5;
    static int defaultDeadlineGap = 1;

    ClientClass client;

    private ExecutorService queuePool;

    private HashMap<Integer, Loan> currentLoans = new HashMap<>();

    public LoanHandler(ClientClass client) {
        this.client = client;

        queuePool = Executors.newFixedThreadPool(MAX_LOAN);
            
        instantiateLoans();
    }

    private boolean authorizeLoanRequest() {
        if (currentLoans.size() >= MAX_LOAN) {
            System.out.println("Maximum amount of loans reached");

            return false;
        }

        return true;
    }

    private void instantiateLoans() {
        CachedRowSet loansData = LoanQueries.getClientLoans(client.id);

        try {
            while (loansData.next()) {
                int id = loansData.getInt("id");
                int accountId = loansData.getInt("account_id");
                
                int loanAmount = loansData.getInt("amount");
                Timestamp deadline = loansData.getTimestamp("date_deadline");

                Loan loanObj = new Loan(id, client.accountController.accountList.get(accountId), loanAmount, deadline);

                currentLoans.put(id, loanObj);
                checkForALoanExpireDate(loanObj);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //* Constantly checking for the expire date */
    private void checkForALoanExpireDate(Loan loanObj) {
        queuePool.submit(() -> {
            try {
                long currTime = new Date().getTime();
                long timeTilExpire = loanObj.deadline.getTime() - currTime;
    
                Thread.sleep(timeTilExpire);
    
                loanObj.expire();

                System.out.println("Loan expired");
            } catch (Exception e) {
                Thread.currentThread().interrupt();

                e.printStackTrace();
            }
        });
    }

    private Timestamp addDays(Timestamp time, int days) {
        Calendar c = Calendar.getInstance();

        c.setTime(time);
        c.add(Calendar.DATE, days);

        //TODO: Add the ps.getGeneratedKeys for queries that entail acquiring the Ids, and use CRS for those that to maintain the ResultSet

        return new Timestamp(c.getTimeInMillis());
    }

    public void applyLoan(BankAccount account, int loanAmount) {
        if (!authorizeLoanRequest()) { return; }

        Timestamp currTime = new Timestamp(new Date().getTime());

        Timestamp deadline = addDays(currTime, 1);

        ResultSet autoGeneratedRS = LoanQueries.insertLoan(account.id, loanAmount, deadline);

        if (autoGeneratedRS == null) { return; }

        try {
            autoGeneratedRS.next();

            int id = autoGeneratedRS.getInt(1);
            
            Loan loanObj = new Loan(id, account, loanAmount, deadline);

            currentLoans.put(id, loanObj);
            account.incrementbalance(loanAmount);

            checkForALoanExpireDate(loanObj);
            Transactions.logLoanAcquisition(account.id, loanAmount);                
            
            System.out.println("Acquired loan successfully " + account.accountName + "'s balance is now: " + account.balance);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

}

class LoanQueries {
    private LoanQueries() {}

    static MysqlConnectionPoolDataSource ds = BankDataConnection.ds;
    private static Connection cn;
    private static CachedRowSet crs;
    
    static {

        try (CachedRowSet newCrs = RowSetProvider.newFactory().createCachedRowSet()) {

            cn = ds.getConnection();

            crs = newCrs;
        } catch (SQLException e) {

            e.printStackTrace();
        }
    }

    static String insertLoanQuery = "INSERT INTO loans(account_id, amount, date_deadline, status) VALUES(?, ?, ?, ?)";

    static ResultSet insertLoan(int account_id, int amount, Timestamp deadline) {

        try {
            PreparedStatement ps = cn.prepareStatement(insertLoanQuery, new String[]{"id"});

            ps.setInt(1, account_id);
            ps.setInt(2, amount);

            ps.setTimestamp(3, deadline);
            ps.setString(4, LoanHandler.PENDING);
            
            ps.execute();

            return ps.getGeneratedKeys();

        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }

    static String getClientLoansQuery = "SELECT * FROM loans WHERE account_id = ?";

    static CachedRowSet getClientLoans(int account_id) {
        try {
            crs.setCommand(getClientLoansQuery);

            crs.setInt(1, account_id);
            
            crs.execute(cn);

        } catch (Exception e) {
            e.printStackTrace();
        }

        return crs;
    }

    static String updateLoanAmountQuery = "UPDATE loans SET loanAmount = ? WHERE id = ?";

    static void updateLoanAmount(int loanId, int newAmount) {
        try (PreparedStatement ps = cn.prepareStatement(updateLoanAmountQuery)) {
        
            ps.setInt(1, newAmount);
            ps.setInt(2, loanId);  
            
            ps.executeUpdate();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    static String updateLoanStatusQuery = "UPDATE loans SET status = ? WHERE id = ?";

    static void updateLoanStatus(int loanId, String newStatus) {
        try (PreparedStatement ps = cn.prepareStatement(updateLoanStatusQuery)) {

            ps.setString(1, newStatus);
            ps.setInt(2, loanId);  
            
            ps.executeUpdate();

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}